package sword_offer;

/**
 * 题目描述
把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 
例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0
 * @author wangshq
 *
 */
public class 旋转数组 {
	
	//第一种，顺序
    public int minNumberInRotateArray(int [] array) {
    	
        for (int i = 1; i < array.length; i++) {
        	if(array[i] < array[i-1]){
        		return array[i];
        	}
		}
        return array[0];
    }
    
    //第二种，用二分的思想
    
    /**
     * 因为这种旋转数组后还是有一定顺序的，所以可以想到使用二分查找来做。
     * 
     * 经过旋转后前面的字符串都是大于后面的字符串，我们只需要找到这两个字符串的分界线即可。
     * 
     * 1. 我们设置两个标志，left,right来标识查找的开始位置和最后的位置。如果旋转了则第一个元素肯定是大于最后一个 的，如果没有旋转则最后一个大于第一个
     * 
     * 2. 我们找到数组中间位置的元素，来和left标志下的进行比较，如果这个元素大于left的元素则说明我们要找的边界在这个中间位置的后面，我们就把left指向中间这个位置
     * 										        如果这个元素小于left的元素则说明我们要找的边界在这个中间位置的前面，我们就把right指向中间这个位置
     * 
     * 3. 最后在left会指向前面最大的元素，right会指向后面最小的元素，也就是说这时候他们俩相邻则right指向的就是我们要找的最小值
     * 
     * 
到目前为止以上思路很耗的解决了没有重复数字的情况，这一道题目添加上了这一要求，有了重复数字。
因此这一道题目比上一道题目多了些特殊情况：
我们看一组例子：｛1，0，1，1，1｝ 和 ｛1，1， 1，0，1｝ 都可以看成是递增排序数组｛0，1，1，1，1｝的旋转。
这种情况下我们无法继续用上一道题目的解法，去解决这道题目。因为在这两个数组中，第一个数字，最后一个数字，中间数字都是1。
第一种情况下，中间数字位于后面的子数组，第二种情况，中间数字位于前面的子数组。
因此当两个指针指向的数字和中间数字相同的时候，我们无法确定中间数字1是属于前面的子数组（绿色表示）还是属于后面的子数组（紫色表示）。
也就无法移动指针来缩小查找的范围。
     * @param array
     * @return
     */
    public int binarySearchMinNumberInRotateArray(int [] array) {
    	return 0;
    }
    
}
